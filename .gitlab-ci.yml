stages:
  - build
  - test
  - build-docker
  - deploy

variables:
  DOCKER_REGISTRY: $CI_REGISTRY                  # GitLab Container Registry
  BACKEND_IMAGE: $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHORT_SHA
  # dind 사용시 TLS 자동 생성 비활성화 (권장)
  DOCKER_TLS_CERTDIR: ""

# ----------------
backend-build:
  stage: build
  image: amazoncorretto:17
  script:
    - cd Backend
    - chmod +x gradlew
    - ./gradlew clean bootJar  # 또는 assemble / build (bootJar가 Spring Boot jar 생성)
  artifacts:
    paths:
      - Backend/build/libs/*.jar
    expire_in: 1 hour
  only:
    - Devops_config

# ----------------
# Backend: build-docker (Docker 이미지 생성 + 푸시)
# ----------------
backend-build-docker:
  stage: build-docker
  image: docker:20.10.16
  services: []
  before_script:
    # GitLab 레지스트리 로그인
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $DOCKER_REGISTRY
  script:
    - ls -la                 # 확인용
    - docker build -t $BACKEND_IMAGE ./Backend
    - docker push $BACKEND_IMAGE
  dependencies:
    - backend-build
  only:
    - Devops_config

# ----------------
# Deploy: ssh로 서버에 deploy.sh 복사 후 실행
# ----------------
deploy-to-server-a:
  stage: deploy
  image: alpine:latest  # 최소화 된 리눅스 환경(이미지)
  before_script:
    - apk add --no-cache openssh-client bash rsync  # SSH 클라이언트, bash, rsync 설치 : SSH로 서버 접속하고 파일 복사할 때 필요
    - mkdir -p ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts                  # 서버의 호스트 키를 미리 등록 -> SSH 접속시 yes/no 묻는 것 방지
    - eval "$(ssh-agent -s)"
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -  # SSH 비밀키를 ssh-agent에 등록
                                                        # $SSH_PRIVATE_KEY = GitLab CI/CD 변수로 등록된 서버 접속용 프라이빗 키
                                                        # 이렇게 해야 Runner가 비밀번호 없이 서버에 SSH 접속 가능
  script:
    # 1. 배포에 필요한 파일들을 서버의 홈 디렉토리로 복사합니다.
    #    배포 스크립트와 docker-compose 파일이 모두 원격 서버에 있어야 합니다.
    - scp Devops/deploy.sh $DEPLOY_SERVER_A:/home/$DEPLOY_USER/deploy.sh
    - scp Devops/docker-compose.server-a.yml $DEPLOY_SERVER_A:/home/$DEPLOY_USER/docker-compose.server-a.yml

    # 2. GitLab Runner의 변수들을 사용해, 원격 서버에 .env 파일을 '동적으로 생성'합니다.
    #    이 파일은 Git에 저장되지 않으며, 오직 배포 서버에만 존재하게 됩니다.
    - ssh $DEPLOY_SERVER_A "echo 'DB_USER=${DB_USER}' > /home/${DEPLOY_USER}/.env"
    - ssh $DEPLOY_SERVER_A "echo 'DB_PASSWORD=${DB_PASSWORD}' >> /home/${DEPLOY_USER}/.env"
    - ssh $DEPLOY_SERVER_A "echo 'DB_NAME=${DB_NAME}' >> /home/${DEPLOY_USER}/.env"
    - ssh $DEPLOY_SERVER_A "echo 'JWT_SECRET=${JWT_SECRET}' >> /home/${DEPLOY_USER}/.env"
    - ssh $DEPLOY_SERVER_A "echo 'JWT_ACCESSTOKENEXPIRATIONMS=${JWT_ACCESSTOKENEXPIRATIONMS}' >> /home/${DEPLOY_USER}/.env"
    - ssh $DEPLOY_SERVER_A "echo 'JWT_REFRESHTOKENEXPIRATIONMS=${JWT_REFRESHTOKENEXPIRATIONMS}' >> /home/${DEPLOY_USER}/.env"

    # 3. 원격 서버의 홈 디렉토리로 이동하여, 생성된 .env 파일과 함께 배포 스크립트를 실행합니다.
    - ssh $DEPLOY_SERVER_A "cd /home/${DEPLOY_USER} && chmod +x deploy.sh && ./deploy.sh $BACKEND_IMAGE"
  only:
    - Devops_config
